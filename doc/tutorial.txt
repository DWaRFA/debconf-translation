Introduction
------------

This is a guide to using debconf with your packages, aimed at a Debian
developer. 

So, what is debconf? To save you reading the spec
(http://www.debian.org/~wakkerma/config6/), debconf is a backend database,
with a frontend that talks to it and presents an interface to the user.
There can be many different types of frontends, from plain text to a web
frontend. The frontend also talks to a special config script in the control
section of a debian package, and it can talk to postinst scripts and other
scripts as well, all using a special protocol. These scripts tell the
frontend what values they need from the database, and the frontend asks the
user questions to get those values if they aren't set.

Debconf should be used whenever your package needs to output something to
the user, or ask a question of the user. I'll assume you already have a
package that does this and you want to convert it to use debconf.

Getting started
---------------

First, your package must depend on debconf (or pre-depend on it if it uses
debconf in its preinst). This is necessary since debconf isn't part of the
base system.

The first thing to do is look at your postinst, plus any program your
postinst calls (like a "packageconfig" program), plus your preinst, and even
your prerm and postrm. Take note of all output they can generate and all
input they prompt the user for. All this output and input must be eliminated
for your package to use debconf. (Output to stderr can be left as is.)

For example, a hypothetical package "foo" has the following postinst:

  #!/bin/sh -e
  echo -n "Do you like debian? [yn] "
  read like
  case "$like" in
  n*|N*)
    echo "Poor misguided one. Why are you installing this package, then?"
    /etc/init.d/subliminal_messages start "I like debian."
  ;;
  esac

It's clear that it asks a question and sometimes outputs a message. We will
need to use debconf to do both.

The Templates file
-------------------

Start writing a debian/templates file. Each time you find a piece of output
or a question, add it to the file as a new template. The format of this file
is simple and quite similar to a Debian control file:

  Template: <packagename>/<something>
  Type: <select,string,boolean,note,text,password>
  Default: <an optional default value>
  Description: Blah blah blah?
   Blah blah blah. Blah blah. Blah blah blah. Blah blah? Blah blah blah. Blah
   blah. Blah blah blah. Blah blah.
   .
   Blah blah blah. Blah blah. Blah blah blah. Blah blah. Blah blah blah. Blah
   blah.

  <next template here>

A short description of the data types:

  string
  	Holds any arbitrary string of data.
  boolean
  	Holds "true" or "false".
  select
  	Holds one of a finite number of possible values. These
  	values must be specified in a field named Choices:. Separate the
  	possible values with commas and spaces, like this: 
  		Choices: yes, no, maybe
  note
  	This template is a note that can be displayed to the user. As
	opposed to text, it is something important, that the user really
	should see. If debconf is not running interactively, it might be
	saved to a log file or mailbox for them to see later.
  text
	This template is a scrap of text that can be displayed to the user.
  password
  	Prompts for a password (with no echoing).

Following along in our example, we create a templates file with two
templates in it:

  Template: foo/like_debian
  Type: boolean
  Description: Do you like Debian?
   We'd like to know if you like the Debian GNU/Linus system.

  Template: foo/why_debian_is_great
  Type: note
  Description: Poor misguided one. Why are you installing this package, then?
   Debian is great. As you continue using Debian, we hope you will discover
   the error in your ways.

The Config Script
-----------------

Next, decide what order the questions should be asked and the messages to
the user should be displayed, figure out what tests you'll make before
asking the questions and displaying the messages, and start writing a
debian/config file to ask and display them. Depending on what language you
choose to write debian/config in, you have some choices about how to
communicate with the frontend:

  shell script:
  
  	You can source /usr/share/debconf/confmodule.sh, which will make
  	a number of shell functions available to you. Each shell function
  	corresponds to a command in the protocol (with "db_" prefixed to
  	its name). You pass parameters to it and get a result back in the
  	$RET variable.  For details, see confmodule.3. 

  perl:
  
  	You can use the Debian::DebConf::Client::ConfModule perl module,
  	which makes a number of functions available to you. Each function
  	corresponds to a command in the protocol -- you pass parameters into
  	it and it returns the result. For details, see the 
  	Debian::Debconf::Client::ConfModule.2pm man page.

  other:
  
        You'll have to communicate with the frontend directly via standard
  	input and standard output. This isn't hard; read the protocol
  	specification for details.

A list and description of all the commands you can use to talk to the
frontend is at the end of this document in Appendix A. The most common
commands you will use in the config script are "input", "go", and "get".
Briefly, "input <priority> <variable>" asks the frontend to make sure it has
asked the user for the value of a variable, specifying how important it is
the user be asked this. The variable names normally correspond to the names
of the templates in the template files. "go" tells the frontend to display
all accumulated input commands to the user. And "get <variable>" asks the
frontend to return to you what value a variable is set to.

Continuing the example, we need a config script to display the first
question, and if the user says they do not like debian, it should display
the message about that.

  #!/bin/sh -e
  
  # Source debconf library.
  . /usr/share/debconf/confmodule.sh

  # Do you like debian?
  db_input medium foo/like_debian
  db_go
  
  # Check their answer.
  db_get foo/like_debian
  if [ "$RET" = "false" ]; then
  	# Poor misguided one..
	db_input high foo/why_debian_is_great
	db_go
  fi

Note that the debian/config script is run before the package is unpacked. It
should only use commands that are in the base system. Also, it shouldn't
actually edit files on the system, or affect it in any other way.

Modifying Existing Maintainer Scripts
-------------------------------------

Once you have a templates file and a config script, it's time to move on to
using the data your config script collects in other maintainer scripts of
your package, like your postinst. Just like the config script, the postinst
and other maintainer scripts can use the confmodule.sh or
Debian::DebConf::Client::ConfModule libraries, or they can speak directly to
the frontend on standard output. 

Anything your maintainer scripts output to standard output is passed into
the frontend as a command, so you need to remove all extraneous noise, like
the starting and stopping of daemons, etc.

The only command postinsts normally use to communicate with the frontend is
"get" (though in reality they can use any commands, including "input", you
are advised not to do so). Typically, the config script prompts the user for
input, and the postinst then pulls that input out of the database via the
get command. 

In the example, before debconf, the package's postinst did this:

  #!/bin/sh -e
  echo -n "Do you like debian? [yn] "
  read like
  case "$like" in
  n*|N*)
  	echo "Poor misguided one. Why are you installing this package, then?"
	/etc/init.d/subliminal_messages start "I like debian."
  ;;
  esac

Our config script already handles most of this. After debconf, the postinst
becomes:

  #!/bin/sh -e

  # Source debconf library.
  . /usr/share/debconf/confmodule.sh  

  deb_get foo/like_debian
  if [ "$RET" = "false" ]; then
  	/etc/init.d/subliminal_messages start "I like debian."
  fi

There is one other alteration you need to make to the postrm script. When
your package is purged, it should get rid of all the questions and templates
it was using in the database. Accomplishing this is simple; use the "purge"
command (make sure you don't fail if debconf has already been removed,
though):

  if [ "$1" = "purge" -a -e /usr/share/debconf/confmodule.sh ]; then
  	# Source debconf library.
	. /usr/share/debconf/confmodule.sh
	# Remove my changes to the db.
	db_purge
  fi

Note that debhelper will do this for you if you use the dh_installdebconf
command.

Finishing Up
------------

Now you have a config script and a templates file. Install both into
debian/tmp/DEBIAN. Make sure to make the config script executable. (If you
use debhelper, this will all be done automatically.) Your package now uses
debconf!

Advanced Topics
---------------

Now I'll move on to some more complicated areas of debconf.

Infinite Loop Prevention
- - - - - - - - - - - - -

One gotcha with debconf comes up if you have a loop in your config script.
Suppose you're asking for input and validating it, and looping if it's not
valid:

  ok=''
  do while [ ! "$ok" ];
  	db_input low foo/bar
	go

  	db_get foo/bar
  	if [ "$RET" ]; then
		ok=1
	fi
  done

This looks ok at first glance. But consider what happens if the value of
foo/bar is "" when this loop is entered, and the user has their priority set
high, or is using a non-interactive frontend, and so they are not really
asked for input. The value of foo/bar is not changed by the db_input, and so
it fails the test and loops. And loops....

The fix for this is to make sure that before the loop is entered, the value
of foo/bar is set to something that will pass the test in the loop. So for
example if the default value of foo/bar is "1", then "db_reset" can just be
called before entering the loop.

Another fix is to use the "visible" command to test if the user will be
prompted, and skip the loop if not.

Choosing amoung related packages
- - - - - - - - - - - - - - - - -

Sometimes a set of related packages can be installed, and you want to prompt
the user which of the set should be used by default. Examples of such sets
are window managers, or ispell dictionary files. While it would be possible
for each package in the set to simply prompt "Should this package be
default?", this leads to a lot of repetative questions if several of the
packages are installed. It's possible with debconf to present a list of all
the packages in the set and allow the user to choose between them. Here's how.

Make all the packages in the set use a shared template. Something like this:

  Template: shared/window-manager
  Type: select
  Choices: ${choices}
  Description: Select the default window manager.
   Select the window manager that will be started by default when X
   starts.

Each package should include a copy of the template. Then it should include
some code like this in its config script:

  db_metaget shared/window-manager owners
  OWNERS=$RET
  db_metaget shared/window-manager choices
  CHOICES=$RET
  
  if [ "$OWNERS" != "$CHOICES" ]; then
  	db_subst shared/window-manager choices $OWNERS
	db_fset shared/window-manager isdefault false
	db_input medium shared/window-manager
	db_go
  fi

A bit of an explination is called for. By the time your config script runs,
debconf has already read in all the templates for the packages that are
being installed. Since the set of packages share a question, debconf records
that fact in the owners field. By a strange cooincidence, the format of the
owners field is the same as that of the choices field (a comma and space
delimited list of values).

The "metaget" command can be used to get the list of owners and the list of
chocies. If they are differnet, then a new package has been installed. So
use the "subst" command to change the list of choices to be the same as the
list of owners, and ask the question.

One thing this doesn't deal with is what happens if the package selected as
the default is removed. If that happens you probably want to make some other
package the default. Doing so is left as an excercise for the reader.

Appendix A.
-----------

Here is a complete list of the the commands you can use to communicate with 
the  frontend (remember these are prefixed with "db_" if you are using
confmodule.sh).

version <number>

	This exchanges with the frontend the protocol version number that is
	being used. The current version is 1.0. Versions in the 1.x series
	will be backwards-compatible. You can specify the protocol version
	number you are speaking, but note that the perl and shell libraries
	specify a good default for you. The frontend will return the version
	of the protocol it speaks.

capb <capabilities>
	
	This exchanges with the frontend the capabilities that are supported.
	Capabilities both the frontend and you send will be used. Currently
	supported capabilities:
		backup - backing up to a previous step is supported.

title <string>

	You can use this command to set a title in the frontend. This
	in different ways, depending on the frontend being used, for example
	it might change the title of the frontend's window. If you don't
	specify anything, a title will automatically be generated.

stop

	This command tells the frontend you're done talking to it.
	
input <priority> <variable>

	This tells the frontend you are interested in the value of a variable.
	<variable> is the name of the variable, which should correspond to
	the Template: line of the template that defines this variable. 
	<priority> is how important it is that the user be prompted for the
	variable. Supported priorities:
		low
			Use this for very trivial items that have defaults that
		        will work in the vast majority of cases.
		medium 
			Use this for normal items that have reasonable
			defaults.
		high
			Use this for items that don't have a reasonable
			default.
		critical
			Use this only for items that will probably break
			the system without user intervention.
			
	Note that the frontend decides if the user is actually prompted or
	not. If the user has already answered a question, they are normally
	not asked it again even if input is called again. And if the user is
	ignoring low priority items, they will not see them.

visible <priority> <variable>

	Ask the frontend if it would actually show a question to the user if
	you ran "input <priority> <variable>". Returns "true" or "false".

beginblock
endblock

	Some frontends are able to display a number of items to the user
	at once. To do this, they need to be given blocks of input commands,
	enclosed in the beginblock and endblock commands. Blocks can be
	nested and very advanced frontends may use this as a user interface
	hint.

go

	Shows the current set of accumulated items to the user and lets
	them fill in values, etc.
	
clear

	Clears the accumulated set of items without displaying them
	to the user.
	
get <variable>

	Ask the frontend to tell you the value of a variable. The value is
	returned to you.

set <variable> <value>

	Ask the frontend to set a variable to a value.

reset <variable>

	Reset the variable to its default value.

subst <variable> <key> <value>

	Variables can have substitutions embedded in their descriptions.
	These substitutions look like "${key}". When the description
	is displayed, the substitutions are replaced with their values.
	This command can be used to set the value of a substitution.

fget <variable> <flag>

	Variables can have flags associated with them. The flags have
	a value of "true" or "false". This command returns the value
	of a flag.

fset <variable> <flag> <value>

	This sets the value of a flag on a variable. Valid values for the
	flag are "true" and "false". One common flag is the "isdefault"
	flag. It is normally only set if the variable is set to its
	default value and the user has not seen it. Typically, frontends
	only display questions to users if they have the isdefault flag set.
	Sometimes you want the user to see a question again -- in these cases
	you can set the isdefault flag to true to force the frontend to
	redisplay it.

metaget <variable> <field>

	This returns the value of any field of a variable.

register <template> <variable>

	This creates a new variable that is bound to a template. By default
	each template has an associated variable with the same name. However,
	any number of variables can really be associated with a template, and
	this lets you create more such variables.

unregister <variable>

	This removes a variable from the database.

purge

	Call this in your postinst when your package is purged. It removes all
	templates and variables your package has generated.

#!/usr/bin/perl -w

=head1 NAME

dpkg-preconfigure - let packages ask questions prior to their installation

=head1 SYNOPSIS

 dpkg-preconfigure [--frontend=type] [--priority=value] package.deb

=head1 DESCRIPTION

B<dpkg-preconfigure> lets packages ask questions before they are installed.
It operates on a set of debian packages, and all packages that use debconf
will have their config script run so they can examine the system and ask
questions.

=head1 OPTIONS

=over 4

=item B<-f>I<type>, B<--frontend=>I<type>

Select the frontend to use. The default frontend can be permanently changed
by:

 dpkg-reconfigure --priority=medium debconf

Currently available frontends are slang, dialog, text, and web.

=item B<-p>I<value>, B<--priority=>I<value>

Set the lowest priority of questions you are interested in. Valid
priorities are currently low, medium, high, and critical. The default
priority can be permanently changed by:

 dpkg-reconfigure --priority=medium debconf

Any questions with a priority below the selected priority will be ignored
and their default answers will be used.

=item B<--apt>

Run in apt mode. It will expect to read a set of package filenames from
stdin, rather than getting them as parameters. Typically this is used to
make apt run dpkg-preconfigure on all packages before they are installed.
To do this, add something like this to /etc/apt/apt.conf:

 // Pre-configure all packages before
 // they are installed.
 DPkg::Pre-Install-Pkgs {
 	"dpkg-preconfigure --apt --priority=low";
 };

=item B<-h>, B<--help>

Display usage help.

=back

=cut

# This program may be running from apt. If so, if it fails, apt is going to
# fail as well, which will make it hard for people to fix whatever the failure
# was. One thing someone encountered was perl failing to install. Apt then
# was re-run with perl unpacked and not configured, and modules weren't
# able to be loaded. As a sanity check, detect that case. If found, exit with
# an error message, but a return code of 0 so apt continues.
BEGIN {
	eval qq{
		use strict;
		use FileHandle;
		use Debian::DebConf::ConfigDb qw(loaddb savedb 
					         loadtemplatefile);
		use Debian::DebConf::Config qw(frontend priority showold
					       dbdir tmpdir);
		use Debian::DebConf::AutoSelect qw(:all);
		use Debian::DebConf::Version;
		use Debian::DebConf::Gettext;
	};
	if ($@) {
		# Don't use gettext() on this because it may have failed to
		# load.
		print STDERR "debconf: Perl may be unconfigured ($@) -- aborting\n";
		exit 0;
	}
}

# In apt mode, need unbuffered output.
$|=1;

# Parse command line. I don't use Getopt::Long since it's not in base.
my @debs;
my $apt='';
for (my $x=0; $x < @ARGV;) {
	$_=$ARGV[$x++];
	
	if ($_ eq '--apt') {
		$apt=1;
	}
	elsif (/^-(?:f|-frontend=)(.*)/) {
		frontend($1);
	}
	elsif (/^-(?:f|-frontend)$/) {
		frontend($ARGV[$x++]);
	}
	elsif (/^-(?:p|-priority=)(.*)/) {
		priority($1);
	}
	elsif (/^-(?:p|-priority)$/) {
		priority($ARGV[$x++]);
	}
	elsif (/^-(?:h|-help)$/) {
		print STDERR gettext("Usage: dpkg-preconfigure [--frontend=type] [--priority=value] debfiles")."\n";
		exit 1;
	}
	elsif (/^--?(\w+)/) {
		print STDERR gettext(sprintf("Unknown option: %s", $1))."\n";
	}
	else {
		push @debs, $_;
	}
}
@ARGV=();

# If running from apt, read package filenames on stdin.
if ($apt) {
	while (<>) {
		chomp;
		push @debs, $_ if length $_;
	}
	
	# If there are less than 2 packages being installed, bail as an
	# optimization. No point in pre-configuring 1 package, after all.
	exit unless @debs > 1;
	
	# We have now reached the end of the first file on stdin.
	# Future reads from stdin should get input from the user, so re-open.
	open (STDIN, "/dev/tty") ||
		(print STDERR gettext(sprintf("dpkg-preconfigure: unable to re-open stdin: %s", $!))."\n", exit 0);

	# Since we are running from apt, we will be preconfiguring some
	# packages prior to installing them. If the user has debconf configured
	# to re-ask seen questions, they will see the questions twice --
	# once when the package is preconfigured, and once when it is installed
	# to avoid that, turn off reasking of questions for the lifetime of
	# this program. The user will thus see the questions only once, when
	# the package is actually installed.
	# This is a hack, but it's the best I can do.
	showold('false');
}

# Load up previous state information.
loaddb(dbdir());

my $frontend=make_frontend();

# Caches package names so they are only looked up once.
my %packages;

# Packages that have templates
my %todo;

# Make two passes -- first load all templates, then run all             
# confmodules. 

foreach my $x (0..$#debs) {
	# Display a little progress indicator similar to what apt uses.
	# This is mostly for showing something is going on during huge
	# upgrades.
	if ($apt) {
		print "\r".(int( ($x+1) / ($#debs+1) * 100)).
			"% [Scanning packages]";
	}

	# See if there are any templates in this deb.
	my $fh=FileHandle->new("dpkg --info $debs[$x] templates 2>/dev/null |");
	if (! $fh->eof) {
		# Now a sanity check: does this package depend
		# on a newer version of debconf than the current
		# version? If so, do nothing to prevent upgrade breaks.
		# The configuration of the package will still happen
		# when its postinst runs.
		#
		# This will also figure out the package name, since
		# that information is needed later.
		my $ok=1;
		open (INFO, "dpkg --info $debs[$x] |");
		while (<INFO>) {
			# Check for versioned debconf dependancy or
			# pre-dependancy, store relation in $1, depended-upon
			# version in $2.
			#
			# NOTE: if there are two debconf dependancies on a
			# line, this only looks at the first
			if (/^ (?:Pre-)?Depends:\s+.*?debconf\s+\(\s*([><=]*)\s+(.*?)\s*\)/i) {
				if (system('dpkg', '--compare-versions', $Debian::DebConf::Version::version, $1, $2) / 256 != 0) {
					$ok='';
				}
			}
			elsif (/^ Package:\s+(.*)/i) {
				$packages{$debs[$x]}=$1;
			}
		}
		close INFO;
	
		if ($ok) {
			eval q{
				loadtemplatefile($fh, $packages{$debs[$x]});
			};
			if ($@) {
				print STDERR "$debs[$x] ".gettext(sprintf("template parse error: %s", $@))."\n";
				next;
			}

			$todo{$debs[$x]}=1;
		}
	}	
}

# Clear progress output.
if ($apt) {
	print "\r". ' ' x 30 . "\r";
}
my $runconfig='';

foreach my $deb (@debs) {
	# Check to see if this deb had any templates. If not, we skip
	# it as an optimization. (It's very unlikely it has any config
	# and if it does, the postinst will run it.)
	next unless $todo{$deb};

	# Check to see if this deb has a confmodule in it. If not,
	# we will skip it. If so, we need to save the confmodule
	# to disk so it can be run.
	open (IN, "dpkg --info $deb config 2>/dev/null |") or
		die gettext(sprintf("Unable to spawn dpkg: %s", $!));
	
	next if eof(IN);
	
	if ($apt && ! $runconfig) {
		$runconfig=1;
		print gettext("Configuring packages ...")."\n";
	}

	my $script=tmpdir()."/config.$$";
	open (OUT, ">$script") or die "$script: $!";
	print OUT <IN>; # TODO: optimize.
	close IN;
	close OUT;
	chmod(0755, $script) or 
		die gettext(sprintf("Can't chmod: %s", $!));

	$frontend->default_title($packages{$deb});

	# Start up the confmodule, passing in the package version.
	my $confmodule=make_confmodule($script, 'configure',
		getversion($packages{$deb}));

	# Make sure any questions created are owned by the correct package.
	$confmodule->owner($packages{$deb});

	# Talk to it until it is done.
	1 while ($confmodule->communicate);

	# I could just exit, but it's good to be robust so 
	# other packages can still be configured and installed.
	if ($confmodule->exitcode > 0) {
		print STDERR gettext(sprintf(
			"%s failed to configure, with exit code %s", 
			$packages{$deb}, $confmodule->exitcode))."\n";
	}

	unlink $script;
}

$frontend->shutdown;

# Save state.
savedb(dbdir());

# Pass a package name, and the version of that package that is currently
# installed is returned.
#
# The function in this block deals with the dpkg status file and is
# memoized. I parse the dpkg status file the first time it's called and
# return all else from a cache. I probably need to know the versions of
# several packages that are being installed, and calling dpkg -s for each
# would be unbearably slow. Since this program should be in dpkg anyway,
# I have few compunctions about parsing the file directly.
{
	my $haveversions='';
	my %versions;
	
	sub getversion {
		my $package=shift;
		
		if ($haveversions) {
			return $versions{$package} if defined $versions{$package};
			return ''; # not installed
		}

		{
			local $/="\n\n";
			open (STATUS, "</var/lib/dpkg/status");
			while (<STATUS>) {
				my ($package)=m/Package:\s*(.*?)\n/;
				($versions{$package})=m/Version:\s*(.*?)\n/;
				if (! defined $versions{$package}) {
					$versions{$package}='';
				}
			}
			close STATUS;
		}
		$haveversions=1;
		return $versions{$package} if defined $versions{$package};
		return ''; # not installed
	}
}

=head1 AUTHOR

Joey Hess <joey@kitenet.net>

=cut


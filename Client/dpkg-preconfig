#!/usr/bin/perl -w
#
# Pre-config tool. This tool can be pointed at a number of .deb files
# that have not yet been installed. It extracts the confmodules and templates
# from them and asks any necessary questions, storing the results in the
# database for later use.

# This program may be running from apt. If so, if it fails, apt is going to
# fail as well, which will make it hard for people to fix whatever the failure
# was. One thing someone encountered was perl failing to install. Apt then
# was re-run with perl unpacked and not configured, and lib.pm wasn't able
# to be loaded. As a sanity check, detect that case. If found, exit with
# an error message, but a return code of 0 so apt continues.
BEGIN {
	eval qq{
		use strict;
		use lib '.';
		use Getopt::Long;
		use Fcntl;
		use POSIX qw(tmpnam);
		use Debian::DebConf::ConfigDb;
		use Debian::DebConf::Config;
		use Debian::DebConf::AutoSelect;
	};
	if ($@) {
		print STDERR "Warning: Perl may be unconfigured ($@)\n";
		exit 0;
	}
}

# In apt mode, need unbuffered output.
$|=1;

my $apt;
Getopt::Long::config qw(bundling no_ignore_case permute);
my $ret=GetOptions(
	"frontend|f=s" => sub { shift; ebian::DebConf::Config::frontend(shift) },
	"priority|p=s" => sub { shift; Debian::DebConf::Config::priority(shift) },
	"apt|a" => \$apt,
);

my @debs=@ARGV;

# If running from apt, read package filenames on stdin.
if ($apt) {
	# Apt runs us with the cursor not on a new line. Advance one line.
	print "\n";

	while (<>) {
		chomp;
		push @debs, $_ if $_;
	}
	# We have now reached the end of the first file on stdin.
	# Furure reads from stdin will get input from the user.
}

# Load up previous state information.
if (-e Debian::DebConf::Config::dbfn()) {
	Debian::DebConf::ConfigDb::loaddb(Debian::DebConf::Config::dbfn());
}

my $frontend=Debian::DebConf::AutoSelect::frontend();

# Caches package names so they are only looked up once.
my %packages;
# Caches package versions.
my %versions;

# Make two passes -- first load all templates, then run all confmodules.
foreach my $x (0..$#debs) {
	# Display a little progress indicator similar to what apt uses.
	# This is mostly for showing something is going on during huge
	# upgrades.
	if ($apt) {
		print "\r".(int( ($x+1) / ($#debs+1) * 100)).
			"% [Scanning packages]";
	}

	# A little optimization: run it once to get 2 values. We have to parse
	# the output though.
	$_=`dpkg-deb -f $debs[$x] Package Version`;
	($packages{$debs[$x]}, $versions{$debs[$x]})=m/^Package: (.*)\nVersion: (.*)\n/;

	# Load up templates.
	Debian::DebConf::ConfigDb::loadtemplatefile(
		"dpkg --info $debs[$x] templates 2>/dev/null |",
	        $packages{$debs[$x]});
}

if ($apt) {
	print "\n";
}
my $runconfig='';

foreach my $deb (@debs) {
	# Check to see if this deb has a confmodule in it. If not,
	# we will skip it. If so, we need to save the confmodule
	# to disk so it can be run.
	open (IN, "dpkg --info $deb config 2>/dev/null |") or
		die "Unable to spawn dpkg: $!";
	my @config=<IN>;
	close IN;
	
	next unless @config;
	
	if ($apt && ! $runconfig) {
		$runconfig=1;
		print "Configuring packages..\n"
	}

	# Open a temp file safely and save the confmodule to it.
	my $script;
	do { $script = tmpnam() }
		until sysopen(OUT, $script, O_RDWR|O_CREAT|O_EXCL);
	print OUT @config;
	close OUT;
	chmod(0755, $script) or 
		die "Can't chmod: $!";

	$frontend->default_title($packages{$deb});

	# Start up the confmodule, passing in the package version.
	my $confmodule=Debian::DebConf::AutoSelect::confmodule($script,
		'configure', $versions{$deb});

	# Make sure any questions created are owned by the correct package.
	$confmodule->owner($packages{$deb});

	# Talk to it until it is done.
	1 while ($confmodule->communicate);

	exit $confmodule->exitcode if $confmodule->exitcode > 0;

	unlink $script;
}

# Save state.
Debian::DebConf::ConfigDb::savedb(Debian::DebConf::Config::dbfn());

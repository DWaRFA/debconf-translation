#!/usr/bin/perl -w
#
# Pre-config tool. This tool can be pointed at a number of .deb files
# that have not yet been installed. It extracts the confmodules, templates,
# and mappings from them and asks any necessary questions, storing the results
# in the database for later use.

use strict;
use Debian::DebConf::ConfigDb;
use Debian::DebConf::FrontEnd::Line;
use Debian::DebConf::FrontEnd::Dialog;
use Debian::DebConf::FrontEnd::Web;
use Debian::DebConf::ConfModule::Dialog;
use Debian::DebConf::ConfModule::Line;
use Debian::DebConf::ConfModule::Web;
use Debian::DebConf::Priority;
use Getopt::Long;

my $frontend_type='Dialog';
my $priority;
Getopt::Long::config qw(bundling no_ignore_case permute);
my $ret=GetOptions(
	"frontend|f=s" => \$frontend_type,
	"priority|p=s" => sub { shift; Debian::DebConf::Priority::set(shift) },
);
$frontend_type=ucfirst($frontend_type);

foreach my $deb (@ARGV) {
	# Check to see if this deb has a confmodule in it. If not,
	# we will skip it. If so, we need to save the confmodule
	# to be run later.
	open (IN, "dpkg --info $deb config |") or
		die "Unable to spawn dpkg: $!";
	my @config=<IN>;
	close IN;
	next unless @config;
	my $script=tmpfile();
	open (OUT, ">$script") or
		die "Can't write to temporary file $script: $!";
	print OUT @config;
	close OUT;
	chmod(0755, $script) or 
		die "Can't chmod: $!";

	# Load up templates.
	Debian::DebConf::ConfigDb::loadtemplatefile("dpkg --info $deb templates|");

	# Load up mappings.
	Debian::DebConf::ConfigDb::loadmappingfile("dpkg --info $deb mappings|");

	# Instantiate all questions that have mappings.
	Debian::DebConf::ConfigDb::makequestions();

	# Start up the FrontEnd and ConfModule.
	my $frontend=eval "Debian::DebConf::FrontEnd::$frontend_type->new()";
	die $@ if $@;
	my $confmodule=eval 'Debian::DebConf::ConfModule::'.$frontend_type.'->new($script, $frontend)';
	die $@ if $@;

	# Talk to it until it is done.
	1 while ($confmodule->communicate);
	
	unlink $script;
}

use Fcntl;
use POSIX qw(tmpnam);

# Get a temp file safely.
sub tmpfile {
	my $name;
	# try new temporary filenames until we get one that didn't already
	# exist;  the check should be unnecessary, but you can't be too careful
	do { $name = tmpnam() }
		until sysopen(FH, $name, O_RDWR|O_CREAT|O_EXCL);
	close FH;	
	$name;
}

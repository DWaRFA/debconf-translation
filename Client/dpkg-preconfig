#!/usr/bin/perl -w
#
# Pre-config tool. This tool can be pointed at a number of .deb files
# that have not yet been installed. It extracts the confmodules and templates
# from them and asks any necessary questions, storing the results in the
# database for later use.

use strict;
use lib '.';
use Debian::DebConf::ConfigDb;
use Debian::DebConf::Config;
use Getopt::Long;
use Fcntl;
use POSIX qw(tmpnam);

my $apt;
Getopt::Long::config qw(bundling no_ignore_case permute);
my $ret=GetOptions(
	"frontend|f=s" => sub { shift; ebian::DebConf::Config::frontend(shift) },
	"priority|p=s" => sub { shift; Debian::DebConf::Config::priority(shift) },
	"apt|a" => \$apt,
);

my @debs=@ARGV;

# If running from apt, read package filenames on stdin.
if ($apt) {
	while (<>) {
		chomp;
		push @debs, $_ if $_;
	}
	# We have now reached the end of the first file on stdin.
	# Furure reads from stdin will get input from the user.
}

# Load up previous state information.
if (-e Debian::DebConf::Config::dbfn()) {
	Debian::DebConf::ConfigDb::loaddb(Debian::DebConf::Config::dbfn());
}

my $frontend_type=Debian::DebConf::Config::frontend();

# Load up appropriate modules and start up the FrontEnd.
my $frontend=eval qq{
	use Debian::DebConf::ConfModule::$frontend_type;
	use Debian::DebConf::FrontEnd::$frontend_type;
	Debian::DebConf::FrontEnd::$frontend_type->new()
};	
die $@ if $@;

# Caches package names so they are only looked up once.
my %packages;

# Make two passes -- first load all templates, then run all confmodules.
foreach my $deb (@debs) {
	my $package=`dpkg-deb -f $deb Package`;
	chomp $package;
	$packages{$deb}=$package;

	# Load up templates.
	Debian::DebConf::ConfigDb::loadtemplatefile("dpkg --info $deb templates|", $package);
}

foreach my $deb (@debs) {
	# Check to see if this deb has a confmodule in it. If not,
	# we will skip it. If so, we need to save the confmodule
	# to disk so it can be run.
	open (IN, "dpkg --info $deb config 2>/dev/null |") or
		die "Unable to spawn dpkg: $!";
	my @config=<IN>;
	close IN;
	next unless @config;
	
	# Open a temp file safely and save the confmodule to it.
	my $script;
	do { $script = tmpnam() }
		until sysopen(OUT, $script, O_RDWR|O_CREAT|O_EXCL);
	print OUT @config;
	close OUT;
	chmod(0755, $script) or 
		die "Can't chmod: $!";

	$frontend->default_title($packages{$deb});

	# Start up the confmodule.
	my $confmodule=eval 'Debian::DebConf::ConfModule::'.$frontend_type.'->new($frontend, $script)';
	die $@ if $@;

	# Make sure any questions created are owned by the correct package.
	$confmodule->owner($packages{$deb});

	# Talk to it until it is done.
	1 while ($confmodule->communicate);

	exit $confmodule->exitcode if $confmodule->exitcode > 0;

	unlink $script;
}

# Save state.
Debian::DebConf::ConfigDb::savedb(Debian::DebConf::Config::dbfn());

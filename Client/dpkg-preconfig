#!/usr/bin/perl -w
#
# Pre-config tool. This tool can be pointed at a number of .deb files
# that have not yet been installed. It extracts the confmodules and templates
# from them and asks any necessary questions, storing the results in the
# database for later use.

# This program may be running from apt. If so, if it fails, apt is going to
# fail as well, which will make it hard for people to fix whatever the failure
# was. One thing someone encountered was perl failing to install. Apt then
# was re-run with perl unpacked and not configured, and lib.pm wasn't able
# to be loaded. As a sanity check, detect that case. If found, exit with
# an error message, but a return code of 0 so apt continues.
BEGIN {
	eval qq{
		use strict;
		use lib '.';
		use Getopt::Long;
		use Fcntl;
		use POSIX qw(tmpnam);
		use Debian::DebConf::ConfigDb;
		use Debian::DebConf::Config;
		use Debian::DebConf::AutoSelect;
	};
	if ($@) {
		print STDERR "Warning: Perl may be unconfigured ($@)\n";
		exit 0;
	}
}

# In apt mode, need unbuffered output.
$|=1;

my $apt;
Getopt::Long::config qw(bundling no_ignore_case permute);
my $ret=GetOptions(
	"frontend|f=s" => sub { shift; ebian::DebConf::Config::frontend(shift) },
	"priority|p=s" => sub { shift; Debian::DebConf::Config::priority(shift) },
	"apt|a" => \$apt,
);

my @debs=@ARGV;

# If running from apt, read package filenames on stdin.
if ($apt) {
	# Apt runs us with the cursor not on a new line. Advance one line.
	print "\n";

	while (<>) {
		chomp;
		push @debs, $_ if $_;
	}
	# We have now reached the end of the first file on stdin.
	# Furure reads from stdin will get input from the user.

	exit unless @debs;
}

# Load up previous state information.
if (-e Debian::DebConf::Config::dbfn()) {
	Debian::DebConf::ConfigDb::loaddb(Debian::DebConf::Config::dbfn());
}

my $frontend=Debian::DebConf::AutoSelect::frontend();

# Caches package names so they are only looked up once.
my %packages;

# Packages that have templates
my %todo;

# Make two passes -- first load all templates, then run all             
# confmodules. 

{
	# I want to slurp whole templates.
	local $/="\n\n";

	foreach my $x (0..$#debs) {
		# Display a little progress indicator similar to what apt uses.
		# This is mostly for showing something is going on during huge
		# upgrades.
		if ($apt) {
			print "\r".(int( ($x+1) / ($#debs+1) * 100)).
				"% [Scanning packages]";
		}
	
		# See if there are any templates in this deb.
		open (TEMPLATES, "dpkg --info $debs[$x] templates 2>/dev/null |");
		if (! eof(TEMPLATES)) {
			# There are templates, so we need to continue with
			# other expensive stuff.
			$todo{$debs[$x]}=1;
			
			# Figure out the package name.
			$packages{$debs[$x]}=`dpkg-deb -f $debs[$x] Package`;
			chomp $packages{$debs[$x]};
			
			# Process the templates.
			while (<TEMPLATES>) {
				Debian::DebConf::ConfigDb::loadtemplatedata($_, $packages{$debs[$x]});
			}
		}
		close TEMPLATES;
	}
}

if ($apt) {
	print "\n";
}
my $runconfig='';

foreach my $deb (@debs) {
	# Check to see if this deb had any templates. If not, we skip
	# it as an optimization. (It's very unlikely it has any config
	# and if it does, the postinst will run it.)
	next unless $todo{$deb};

	# Check to see if this deb has a confmodule in it. If not,
	# we will skip it. If so, we need to save the confmodule
	# to disk so it can be run.
	open (IN, "dpkg --info $deb config 2>/dev/null |") or
		die "Unable to spawn dpkg: $!";
	
	next if eof(IN);
	
	if ($apt && ! $runconfig) {
		$runconfig=1;
		print "Configuring packages ...\n"
	}

	# Open a temp file safely and save the confmodule to it.
	my $script;
	do { $script = tmpnam() }
		until sysopen(OUT, $script, O_RDWR|O_CREAT|O_EXCL);
	print OUT <IN>; # TODO: optimize.
	close IN;
	close OUT;
	chmod(0755, $script) or 
		die "Can't chmod: $!";

	$frontend->default_title($packages{$deb});

getversion($packages{$deb});
next;

	# Start up the confmodule, passing in the package version.
	my $confmodule=Debian::DebConf::AutoSelect::confmodule($script,
		'configure', getversion($packages{$deb}));

	# Make sure any questions created are owned by the correct package.
	$confmodule->owner($packages{$deb});

	# Talk to it until it is done.
	1 while ($confmodule->communicate);

	exit $confmodule->exitcode if $confmodule->exitcode > 0;

	unlink $script;
}

# Save state.
Debian::DebConf::ConfigDb::savedb(Debian::DebConf::Config::dbfn());

# Pass a package name, and the version of that package is returned.
#
# This function is memoized. I parse the dpkg status file
# the first time it's called and return all else from a cache.
# I probably need to know the versions of several packages that are
# being installed, and calling dpkg -s for each would be unbearably
# slow. Since this program should be in dpkg anyway, I have few compunctions
# about parsing the file directly.
{
	my $haveversions='';
	my %versions;
	
	sub getversion {
		my $package=shift;
		
		return $versions{$package} if $haveversions;
		{
			local $/="\n\n"; # only takes effect in this closure.
			open (STATUS, "</var/lib/dpkg/status");
			while (<STATUS>) {
				my ($package)=m/Package:\s*(.*?)\n/;
				($versions{$package})=m/Version:\s*(.*?)\n/;
			}
			close STATUS;
		}
		$haveversions=1;
		
		return $versions{$package};
	}
}

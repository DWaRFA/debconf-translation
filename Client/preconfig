#!/usr/bin/perl -w
#
# Pre-config tool. This tool can be pointed at a number of .deb files
# that have not yet been installed. It extracts the confmodules, templates,
# and mappings from them and asks any necessary questions, storing the results
# in the database for later use.

use strict;
use ConfigDb;
use FrontEnd::Line;
use FrontEnd::Dialog;
use FrontEnd::Web;
use ConfModule::Dialog;
use ConfModule::Line;
use ConfModule::Web;
use Getopt::Long;

my $frontend_type='Dialog';
my $ret=GetOptions(
	"frontend|f=s", \$frontend_type,
);
$frontend_type=ucfirst($frontend_type);

foreach my $deb (@ARGV) {
	# Check to see if this deb has a confmodule in it. If not,
	# we will skip it. If so, we need to save the confmodule
	# to be run later.
	open (IN, "dpkg --info $deb config |") or
		die "Unable to spawn dpkg: $!";
	my @config=<IN>;
	close IN;
	next unless @config;
	my $script=tmpfile();
	open (OUT, ">$script") or
		die "Can't write to temporary file $script: $!";
	print OUT @config;
	close OUT;
	chmod(0755, $script) or 
		die "Can't chmod: $!";

	# Load up templates.
	ConfigDb::loadtemplatefile("dpkg --info $deb templates|");

	# Load up mappings.
	ConfigDb::loadmappingfile("dpkg --info $deb mappings|");

	# Instantiate all questions that have mappings.
	ConfigDb::makequestions();

	# Start up the FrontEnd and ConfModule.
	my $frontend=eval "FrontEnd::$frontend_type->new()";
	die $@ if $@;
	my $confmodule=eval 'ConfModule::'.$frontend_type.'->new($script, $frontend)';
	die $@ if $@;

	# Talk to it until it is done.
	1 while ($confmodule->communicate);
	
	unlink $script;
}

use Fcntl;
use POSIX qw(tmpnam);

# Get a temp file safely.
sub tmpfile {
	my $name;
	# try new temporary filenames until we get one that didn't already
	# exist;  the check should be unnecessary, but you can't be too careful
	do { $name = tmpnam() }
		until sysopen(FH, $name, O_RDWR|O_CREAT|O_EXCL);
	close FH;	
	$name;
}

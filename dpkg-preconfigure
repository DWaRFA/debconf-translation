#!/usr/bin/perl -w

=head1 NAME

dpkg-preconfigure - let packages ask questions prior to their installation

=head1 SYNOPSIS

 dpkg-preconfigure [options] package.deb

 dpkg-preconfigure --apt

=head1 DESCRIPTION

B<dpkg-preconfigure> lets packages ask questions before they are installed.
It operates on a set of debian packages, and all packages that use debconf
will have their config script run so they can examine the system and ask
questions.

=head1 OPTIONS

=over 4

=item B<-f>I<type>, B<--frontend=>I<type>

Select the frontend to use.

=item B<-p>I<value>, B<--priority=>I<value>

Set the lowest priority of questions you are interested in. Any questions
with a priority below the selected priority will be ignored and their
default answers will be used.

=item B<--apt>

Run in apt mode. It will expect to read a set of package filenames from
stdin, rather than getting them as parameters. Typically this is used to
make apt run dpkg-preconfigure on all packages before they are installed.
To do this, add something like this to /etc/apt/apt.conf:

 // Pre-configure all packages before
 // they are installed.
 DPkg::Pre-Install-Pkgs {
 	"dpkg-preconfigure --apt --priority=low";
 };

=item B<-h>, B<--help>

Display usage help.

=back

=cut

# This program may be running from apt. If so, if it fails, apt is going to
# fail as well, which will make it hard for people to fix whatever the failure
# was. One thing someone encountered was perl failing to install. Apt then
# was re-run with perl unpacked and not configured, and modules weren't
# able to be loaded. As a sanity check, detect that case. If found, exit with
# an error message, but a return code of 0 so apt continues.
BEGIN {
	eval qq{
		use strict;
		use FileHandle;
		use Debconf::Log qw(:all);
		use Debconf::Db;
		use Debconf::Template;
		use Debconf::Config;
		use Debconf::AutoSelect qw(:all);
		use Debconf::Gettext;
	};
	if ($@) {
		# Don't use gettext() on this because it may have failed to
		# load!
		print STDERR "debconf: Perl may be unconfigured ($@) -- aborting\n";
		exit 0;
	}
}

Debconf::Db->load;

my $apt=0;
Debconf::Config->getopt( # TODO: i18n this? What's the best way to break it up?
qq{Syntax: dpkg-reconfigure [options] [debs]
       --apt		Apt mode.},
	"apt"		=> \$apt,
);

# In apt mode, need unbuffered output. Let's just enable it.
$|=1;

my @debs=@ARGV;
@ARGV=();

# If running from apt, read package filenames on stdin.
if ($apt) {
	while (<>) {
		chomp;
		push @debs, $_ if length $_;
	}
	
	exit unless @debs;
	
	# We have now reached the end of the first file on stdin.
	# Future reads from stdin should get input from the user, so re-open.
	open (STDIN, "/dev/tty") ||
		(print STDERR sprintf("dpkg-preconfigure: ".gettext("unable to re-open stdin: %s"), $!)."\n", exit 0);

	# Since we are running from apt, we will be preconfiguring some
	# packages prior to installing them. If the user has debconf
	# configured to re-ask seen questions, they will see the questions
	# twice -- once when the package is preconfigured, and once when it
	# is installed to avoid that, turn off reasking of questions for
	# the lifetime of this program. The user will thus see the
	# questions only once, when the package is actually installed.
	# This is a hack, but it's the best I can do.
	Debconf::Config->showold('false');
}
elsif (! @debs) {
	print STDERR sprintf("dpkg-preconfigure: ".gettext("must specify some debs to preconfigure")), "\n";
	exit(1);
}

if (! -x "/usr/bin/apt-extracttemplates") {
	warn gettext("(not preconfiguring packages since apt-utils is not installed)");
	exit;
}

my $frontend=make_frontend();

# Use the external package scanner for speed. It takes a list of debs
# and outputs to stdout a table with these fields separated by spaces:
my ($package, $version, $template, $config);
# Note that it also handles making sure the current version of debconf can
# deal with the package.
unless (open(INFO, "-|")) {
	# TODO: handle case where params overflow kernel command line limit.
	# a-la-xargs
	exec "apt-extracttemplates", @debs or
		print STDERR "debconf: exec of apt-extracttemplates failed: $!";
}
# Why buffer here? Well, suppose 300 packages are being installed, and
# only the first and last use debconf. The first is preconfigured. Then
# the user watches their ui lock up until it scans all the way to the last..
# Blowing a bit of memory on abuffer seems like a saner approach.
my @buffer=<INFO>;
if ($apt && @buffer) {
	print "Preconfiguring packages ...\n";
}
foreach my $line (@buffer) {
	($package, $version, $template, $config)=split /\s/, $line;
	
	# Load templates if any.
	if (defined $template && length $template) {
		eval q{
			Debconf::Template->load($template, $package)
		};
		unlink $template;
		if ($@) {
			print STDERR "$package ".sprintf(gettext("template parse error: %s"), $@)."\n";
			unlink $config;
			next;
		}
	}
}

foreach my $line (@buffer) {
	($package, $version, $template, $config)=split /\s/, $line;

	# Run config script if any.
	if (defined $config && length $config && -e $config) {
		debug user => "preconfiguring $package ($version)";
		chmod(0755, $config) or
			die sprintf(gettext("debconf: can't chmod: %s"), $!);
		$frontend->default_title($package);
		my $confmodule=make_confmodule($config, 'configure', $version);
		# Make sure any questions created are owned by the correct package.
		$confmodule->owner($package);
		1 while ($confmodule->communicate);
		# I could just exit, but it's good to be robust so
		# other packages can still be configured and installed.
		if ($confmodule->exitcode > 0) {
			print STDERR sprintf(
				gettext("%s failed to preconfigure, with exit status %s"),
				$package, $confmodule->exitcode)."\n";
		}
		unlink $config;
	}
}

$frontend->shutdown;

# Save state.
Debconf::Db->save;

=head1 AUTHOR

Joey Hess <joey@kitenet.net>

=cut


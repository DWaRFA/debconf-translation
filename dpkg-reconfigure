#!/usr/bin/perl -w

=head1 NAME

dpkg-reconfigure - reconfigure an already installed package

=head1 SYNOPSIS

 dpkg-reconfigure [--frontend=type] [--priority=value] packages

=cut

sub usage {
	print STDERR gettext("Usage: dpkg-reconfigure [--frontend=type] [--priority=value] packages")."\n";
	exit 1;
}

=head1 DESCRIPTION

B<dpkg-reconfigure> reconfigures packages after they have already been
installed. Pass it the names of a package or packages to reconfigure.

This has the same effect as re-installing the package, basically. I hope
one day this will be called by dpkg --reconfigure 

=head1 OPTIONS

=over 4

=item B<-f>I<type>, B<--frontend=>I<type>

Select the frontend to use. The default frontend can be permanently changed
by:

 dpkg-reconfigure debconf

Currently availble frontends are slang, dialog, text, and web.

Note that if you normally have debconf set to use the noninteractive
frontend, dpkg-reconfigure will use the slang frontend instead, so you
actually get to reconfigure the package.

=item B<-d>, B<--default-priority>

Use your real default priority when reconfiguring, instead of low priority.
dpkg-reconfigure normally shows low priority questions no matter what your
default priority is.

=item B<--all>

Reconfigure all installed packages that use debconf. Warning: this may take
a long time.

=item B<-u>, B<--unseen-only>

By default, all questions are shown, even if they have already been
answered. If this parameter is set though, only questions that have not yet
been seen will be asked.

=item B<-h>, B<--help>

Display usage help.

=back

=cut

use strict;
use Debconf::Db;
use Debconf::Gettext;
use Debconf::Template;
use Debconf::Config qw(frontend priority showold);
use Debconf::AutoSelect qw(:all);
use Debconf::Log qw(:all);

my $infodir="/var/lib/dpkg/info";

# Parse command line. I don't use Getopt::Long since it's not in base.
my @packages;
my $change_priority=1;
my $unseen_only='';
my $all='';
for (my $x=0; $x < @ARGV;) {
	$_=$ARGV[$x++];
	
	if ($_ eq '--all') {
		@packages=allpackages();
		$all=1;
	}
	elsif (/^-(?:d|-default-priority)$/) {
		$change_priority='';
	}
	elsif (/^-(?:f|-frontend=)(.*)/) {
		frontend($1);
	}
	elsif (/^-(?:f|-frontend)$/) {
		frontend($ARGV[$x++]);
	}
	elsif (/^-(?:p|-priority=)(.*)/) {
		priority($1);
		$change_priority='';
	}
	elsif (/^-(?:p|-priority)$/) {
		priority($ARGV[$x++]);
		$change_priority='';
	}
	elsif (/^-(?:u|-unseen-only)$/) {
		$unseen_only=1;
	}
	elsif (/^-(?:h|-help)$/) {
		usage();
	}
	elsif (/^--?(\w+)/) {
		print STDERR "Unknown option: $1\n";
		usage();
	}
	else {
		push @packages, $_;
	}
}

usage unless @packages;

# See if they are root.
if ($> != 0) {
	warn "$0 ".gettext("must be run as root");
	exit 1;
}

Debconf::Db->load;

# If the default frontend is noninteractive, change it temporarily to
# slang.
if (frontend() eq 'Noninteractive') {
	frontend('Slang');
}

my $frontend=make_frontend();

unless ($unseen_only) {
	# Make the frontend show questions even if the user has already seen
	# them. Since this is a reconfigure program, they may want to change
	# their choices.
	showold('true');
}

# Default to low priority unless some other priority was specified.
priority('low') if $change_priority;

foreach my $pkg (@packages) {
	# Set default title.
	$frontend->default_title($pkg);

	# Get the package version. Also check to make sure it is installed.
	$_=`dpkg --status $pkg`;
	my ($version)=m/Version: (.*)\n/;
	my ($status)=m/Status: (.*)\n/;
	if (! defined $status || $status !~ m/ ok installed$/) {
		warn sprintf(gettext("%s is not fully installed"), $pkg);
		exit 1;
	}
	
	# Load up templates just in case they arn't already.
	Debconf::Template->load("$infodir/$pkg.templates", $pkg)
		if -e "$infodir/$pkg.templates";

	# Run config, and postinst scripts in sequence, with args.
	# Do not run postrm, because the postrm can depend on the package's
	# files actually being gone already.
	foreach my $info (['config',   'reconfigure', $version],
			  ['postinst', 'configure',   $version]) {
		my $script=shift @$info;
		next unless -x "$infodir/$pkg.$script";

		my $is_confmodule='';

		if ($script ne 'config') {
			# Test to see if the script uses debconf.
			open (IN, "<$infodir/$pkg.$script");
			while (<IN>) {
				if (/confmodule/i) {
					$is_confmodule=1;
					last;
				}
			}
			close IN;
		}
		
		if ($script eq 'config' || $is_confmodule) {
			# Start up the confmodule.
			my $confmodule=make_confmodule(
				"$infodir/$pkg.$script", @$info);
	
			# Make sure any questions the confmodule registers are owned
			# by this package.
			$confmodule->owner($pkg);
		
			# Talk to it until it is done.
			1 while ($confmodule->communicate);
	
			exit $confmodule->exitcode if $confmodule->exitcode > 0;
		}
		else {
			# Not a confmodule, so run it as a normal script.
			# Since it might run other programs that do use
			# debconf, checkpoint the current database state
			# and re-initialize it when the script finishes.
			Debconf::Db->save;
						
			$ENV{DEBIAN_HAS_FRONTEND}='';
			my $ret=system("$infodir/$pkg.$script", @$info);
			if (int($ret / 256) != 0) {
				exit int($ret / 256);
			}
			$ENV{DEBIAN_HAS_FRONTEND}=1;
			
			Debconf::Db->import;
		}
	}
}

$frontend->shutdown;

Debconf::Db->save;

# Returns a list of all installed packages.
sub allpackages {
	my @ret;
	local $/="\n\n";
	
	open (STATUS, "</var/lib/dpkg/status")
		|| die sprintf(gettext("Cannot read status file: %s"), $!);
	while (<STATUS>) {
		push @ret, $1
			if m/Status:\s*.*installed\n/ && m/Package:\s*(.*)\n/;
	}
	close STATUS;

	return sort @ret;
}

=head1 AUTHOR

Joey Hess <joey@kitenet.net>

=cut
